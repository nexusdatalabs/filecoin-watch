---
export interface Props {
  data: Array<Record<string, unknown>>;
  x: string;
  y: string;
  label?: string;
  cid?: string;
}

const {
  data = [],
  x,
  y,
  label = "Series",
  cid: passedCid,
} = Astro.props as Props;

// Unique chart id per component instance
const cid = passedCid ?? `linechart-${Math.random().toString(36).slice(2, 10)}`;

// Stable in-page anchor id derived from label or `y`
const slugify = (s: string) =>
  s
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
const anchorId = slugify(label || y);

const labels = (Array.isArray(data) ? data : [])
  .map((d) => (d && typeof d === "object" ? (d as any)[x] : undefined))
  .filter((v) => v !== undefined);

const values = (Array.isArray(data) ? data : []).map((d) => {
  const v = d && typeof d === "object" ? (d as any)[y] : undefined;
  if (v === undefined || v === null) return null;
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
});
---

<figure id={anchorId} class="lc-figure">
  {label && (
    <figcaption class="lc-caption">
      <a href={`#${anchorId}`} class="lc-caption-link" aria-label={`${label} permalink`}>
        {label}
      </a>
    </figcaption>
  )}
  <div class="chart-container">
    <canvas
      data-cid={cid}
      data-x={JSON.stringify(labels)}
      data-y={JSON.stringify(values)}
      data-label={label}
      role="img"
      aria-label={label ? `${label} over time line chart` : "Line chart"}
    >
      {label ? `${label} as a line chart` : "Line chart"}
    </canvas>
  </div>
</figure>

<script>
  import Chart from "chart.js/auto";
  // Date adapter for Chart.js time scale
  import "chartjs-adapter-date-fns";

  // Simple global registry to update all charts when date range changes
  type Point = { x: string; y: number | null };
  type ChartEntry = { canvas: HTMLCanvasElement; chart: any; points: Point[] };
  const registry: Map<string, ChartEntry> = (window as any).__lcRegistry ?? new Map();
  (window as any).__lcRegistry = registry;

  const readRange = () => {
    const sp = new URLSearchParams(location.search);
    const from = sp.get('from') || '';
    const to = sp.get('to') || '';
    return { from, to };
  };

  const within = (d: string, from: string, to: string) => {
    if (from && d < from) return false;
    if (to && d > to) return false;
    return true;
  };

  function applyFilterTo(entry: ChartEntry) {
    const { from, to } = readRange();
    const filtered = (entry.points || []).filter(p => p.x && within(p.x, from, to));
    const ds = entry.chart?.data?.datasets?.[0];
    if (ds) ds.data = filtered;
    entry.chart?.update?.('none');
  }

  function applyFilterAll() {
    registry.forEach((entry) => applyFilterTo(entry));
  }

  // Ensure we only install listeners once
  if (!(window as any).__lcRangeListeners) {
    (window as any).__lcRangeListeners = true;
    window.addEventListener('datefilter:changed', applyFilterAll);
    window.addEventListener('popstate', applyFilterAll);
  }

  // Initialize all LineChart canvases on the page
  const canvases = Array.from(
    document.querySelectorAll(
      "canvas[data-cid][data-x][data-y]:not([data-initialized])",
    ),
  ) as HTMLCanvasElement[];

  // Respect the site's configured monospace font
  const cssFont = getComputedStyle(document.documentElement)
    .getPropertyValue("--font-monospace")
    .trim() || "monospace";
  Chart.defaults.font.family = cssFont;

  // Hardcoded colors (simple, neutral defaults)
  const lineColor = "rgba(17, 17, 17, 0.95)"; // near-black line
  const gridColor = "rgba(17, 17, 17, 0.15)"; // subtle grid
  const tickColor = "rgba(17, 17, 17, 0.75)"; // dark gray ticks
  const tooltipBg = "rgba(255, 255, 255, 0.98)"; // light tooltip bg
  const tooltipFg = "rgba(17, 17, 17, 0.95)"; // dark tooltip fg

  // Fixed width for the left (y) axis so all charts align.
  // Tweak if your labels need more/less room.
  const FIXED_Y_AXIS_WIDTH = 48;

  for (const canvas of canvases) {
    const cid = canvas.dataset.cid as string;
    const x = JSON.parse(canvas.dataset.x || "[]");
    const y = JSON.parse(canvas.dataset.y || "[]");
    const label = canvas.dataset.label || undefined;

    // Assume `x` is always a date string in YYYY-MM-DD
    const points: Point[] = (Array.isArray(x) ? x : []).map((xi: string, i: number) => ({
      x: xi,
      y: y[i],
    }));

    const chart = new Chart(canvas as any, {
      type: "line",
      data: {
        datasets: [
          {
            label: label || undefined,
            data: points,
            borderColor: lineColor,
            backgroundColor: lineColor,
            borderWidth: 1.5,
            pointRadius: 0,
            pointHoverRadius: 0,
            tension: 0.25,
            spanGaps: true,
            fill: false,
          },
        ],
      },

      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        interaction: { mode: "index", intersect: false, axis: "x" },
        scales: {
          y: {
            beginAtZero: true,
            border: { display: false },
            grid: {
              color: gridColor,
              drawOnChartArea: true,
            },
            // Ensure consistent plot-area left edge across charts
            afterFit: (scale: any) => {
              scale.width = FIXED_Y_AXIS_WIDTH;
            },
            ticks: {
              color: tickColor,
              maxTicksLimit: 5,
              padding: 4,
            },
          },
          x: {
            type: "time",
            time: {
              // Show ticks at monthly intervals; data can still be daily
              unit: "month",
              tooltipFormat: "PP",
              displayFormats: {
                hour: "HH:mm",
                day: "MMM d, yyyy",
                month: "MMM",
                year: "yyyy",
              },
            },
            border: { display: false },
            grid: { display: false },
            ticks: {
              color: tickColor,
              autoSkip: true,
              maxRotation: 0,
              minRotation: 0,
              padding: 4,
              // Simple approach: month labels for most ticks, years for major ticks (January)
              major: { enabled: true },
              callback: (value, index, ticks) => {
                const t = (ticks && ticks[index]) as any;
                const v = (t && (t.value ?? t.label)) ?? value;
                const d = new Date(typeof v === "string" ? Number(v) || v : (v as any));
                if (t && t.major) return String(d.getFullYear());
                return d.toLocaleString(undefined, { month: "short" });
              },
            },
          },
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            intersect: false,
            displayColors: false,
            backgroundColor: tooltipBg,
            borderColor: tooltipFg,
            borderWidth: 1,
            titleColor: tooltipFg,
            bodyColor: tooltipFg,
            cornerRadius: 0,
            padding: 6,
            callbacks: {
              label: (ctx) => {
                const v = ctx.parsed?.y;
                return typeof v === "number" ? v.toString() : "";
              },
            },
          },
          title: { display: false },
          decimation: { enabled: true, algorithm: "min-max" },
        },
      },
    });

    // Save original points for filtering and apply current URL range
    registry.set(cid, { canvas, chart, points });
    applyFilterTo(registry.get(cid)!);

    // Mark as initialized to avoid double-instantiation
    canvas.dataset.initialized = "1";
  }
</script>

<style>
  .lc-figure {
    /* Use scroll-margin-top to ensure deep links scroll to a comfortable position */
    scroll-margin-top: var(--space-6);
  }
  .lc-caption {
    margin: 0 0 var(--space-2);
    color: var(--fg);
    font-family: var(--font-monospace);
    font-weight: 600;
    letter-spacing: -0.005em;
    font-size: clamp(0.95rem, 0.6vw + 0.8rem, 1.15rem);
  }
  .lc-caption-link {
    text-decoration: none;
  }
  .lc-caption-link:hover,
  .lc-caption-link:focus { text-decoration: underline; }
  .chart-container {
    position: relative;
    width: 100%;
    height: var(--height, 240px);
  }
  canvas {
    width: 100% !important;
    height: 100% !important;
  }
</style>
